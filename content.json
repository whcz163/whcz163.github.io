[{"title":"模板","date":"2017-11-24T09:41:19.000Z","path":"2017/11/24/模板-1/","text":"","tags":[]},{"title":"字符设备驱动程序","date":"2017-09-18T03:04:51.000Z","path":"2017/09/18/字符设备驱动程序/","text":"字符设备驱动大概步奏；应用程序：open(“/dev/xxx”),,read,write…………………………………………….open(“/dev/xxx”)具有字符设备等的属性，包括主设备号等……………………………………………. c库…………………………………………….VFS:通过字符结构内核定义的一个数组chrev中寻找主设备号，根据主设备号，找到 file_operations这个结构体。……………………………………………..在驱动中我们构建了file_operations这个结构体，这个结构体包含了我们写的read write open ，分别对应led_open,led_read,led_write,等函数。 在入口函数里，我们定义：major = register_chrdev(0主设备号, “first_drv”驱动, &amp;first_drv_fops结构体地址); // 注册, 告诉内核 有入口函数，必有出口函数：把驱动及主设备号给释放了unregister_chrdev(major, “first_drv”); // 卸载 一个linux内核字符串驱动一般由以下几个部分组成：驱动程序包含的一些必须的头文件12345678910#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/delay.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/irq.h&gt;#include &lt;asm/io.h&gt;#include &lt;asm/arch/regs-gpio.h&gt;#include &lt;asm/hardware.h&gt; 程序包含的一些函数，想想具体后面补充12345678910111213141516171819202122232425262728293031323334353637static struct class *firstdrv_class;static struct class_device *firstdrv_class_dev;volatile unsigned long *gpfcon = NULL;volatile unsigned long *gpfdat = NULL;static int first_drv_open(struct inode *inode, struct file *file)&#123; //printk(\"first_drv_open\\n\"); /* 配置GPF4,5,6为输出 */ *gpfcon &amp;= ~((0x3&lt;&lt;(4*2)) | (0x3&lt;&lt;(5*2)) | (0x3&lt;&lt;(6*2))); *gpfcon |= ((0x1&lt;&lt;(4*2)) | (0x1&lt;&lt;(5*2)) | (0x1&lt;&lt;(6*2))); return 0;&#125;static ssize_t first_drv_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)&#123; int val; //printk(\"first_drv_write\\n\"); copy_from_user(&amp;val, buf, count); // copy_to_user(); if (val == 1) &#123; // 点灯 *gpfdat &amp;= ~((1&lt;&lt;4) | (1&lt;&lt;5) | (1&lt;&lt;6)); &#125; else &#123; // 灭灯 *gpfdat |= (1&lt;&lt;4) | (1&lt;&lt;5) | (1&lt;&lt;6); &#125; return 0;&#125; 模块参数，或者宏变量结构体，或对应驱动的设备表，定义一个 file_operations 结构体，12345static struct file_operations first_drv_fops = &#123; .owner = THIS_MODULE, /* 这是一个宏，推向编译模块时自动创建的__this_module变量 */ .open = first_drv_open, .write = first_drv_write, &#125;; 模块加载函数：通过insmod加载驱动时候，模块的加载函数会自动被内核执行，完成模块的初始化工作；1234567int major;static int first_drv_init(void)&#123; /**初始化代码**/major = register_chrdev(0, \"first_drv\", &amp;first_drv_fops); // 注册, 告诉内核&#125;module_init(hello_init); 模块卸载函数：当通过rmmod命令卸载某模块时，模块的卸载函数会被自动被内核执行，完成模块的卸载功能；12345static void hello_exit(first_drv_init)&#123; /**释放代码**/&#125;module_exit(first_drv_exit); 模块的许可证声明：程序需要遵循GPL兼容许可，以及其它等等…最常用的如下：1MODULE_LICENSE(\"GPL\"); 驱动模块 加载分为 静态加载和动态加载。静态加载是在编译内核的时候，就编译进内核，开机后会自动加载。动态加载是将驱动编译成模块，使用insmod命令加载。加到启动脚本里让其开机自动加载，算是一种技巧，不是标准的方法。二期毕业班，记不到了。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自 www.cetiic.cn ，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"2440驱动","slug":"2440驱动","permalink":"http://yoursite.com/tags/2440驱动/"}]},{"title":"LED驱动","date":"2017-09-18T03:04:51.000Z","path":"2017/09/18/led驱动/","text":"字符设备驱动之hello、led等； 最简单的驱动 hello_呵呵呵hello_drv之前为了省事在sublime 中编写代码，错误压根发现不了，后来用到source insight关键字 彩色标注，相对好多了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/delay.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/irq.h&gt;#include &lt;asm/io.h&gt;#include &lt;asm/arch/regs-gpio.h&gt;#include &lt;asm/hardware.h&gt;static int hello_drv_open(struct inode *inode, struct file *file)&#123; printk(\" this is my first devices\\n\"); return 0;&#125;static ssize_t hello_drv_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)&#123; printk(\" hello_drv_write000000\\n\"); return 0;&#125;static struct file_operations hello_drv_fops = &#123; .owner = THIS_MODULE, /* 这是一个宏，推向编译模块时自动创建的__this_module变量 */ .open = hello_drv_open, .write = hello_drv_write,&#125;;static int hello_drv_init(void)&#123; register_chrdev(0, \"hello_drv\", &amp;hello_drv_fops); // 注册, 告诉内核&#125;static void hello_drv_exit(void)&#123; unregister_chrdev(0, \"hello_drv\"); // 卸载&#125;module_init(hello_drv_init);module_exit(hello_drv_exit);MODULE_LICENSE(\"GPL\"); 对应的Makefile12345678910 KERN_DIR = /work/system/linux-2.6.22.6all: make -C $(KERN_DIR) M=`pwd` modules clean: make -C $(KERN_DIR) M=`pwd` modules clean rm -rf modules.orderobj-m += hello_drv.o 然后 make，一个驱动做完，会出现各种错误，慢慢改吧 hellodrv_test最简单的一个测试程序，毫不拖泥带水123456789101112131415161718#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; int fd; int val = 1; fd = open(\"/dev/xyz\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open!\\n\"); &#125; write(fd, &amp;val, 4); return 0;&#125; 对这个.c的gun c函数进行编译，在ubunt中arm-linux-gcc -o hellodrv_test hellodrv_test.c编译完成后，进入调试 发现 ./hellodrv_test 压根没反应 出现/cannot open创建设备节点，字符设备 主设备号通过 cat /proc/devices 发现是252mknod /dev/xyz c 252 0此时 ./hellodrv_test 会出现驱动打印的数据 自动分配主设备号码在驱动程序中可以自动分配主设备号，也可以手工指定主设备号；在应用程序中的是怎么来的呢?fd = open(&quot;/dev/xyz&quot;, O_RDWR);可以手工分配主设备号：mknod /dev/xxx c 111 0也可以自动创建设备号：在应用程序中有个udev机制，对我们的buybox 就是mdevmdev 根据系统信息创建设备节点，首先在驱动程序中定义两个变量：static struct class *leds_class;///定义一个leds的类static struct class_device *leds_class_devs[4];///在类下面创建设备 然后在init函数中123firstdrv_class = class_create(THIS_MODULE, \"firstdrv\");firstdrv_class_dev = class_device_create(firstdrv_class, NULL, MKDEV(major, 0), NULL, \"xyz\"); /* /dev/xyz */\\ 对应的在exit函数中释放:12class_device_unregister(hellodrv_class_dev);class_destroy(hellodrv_class); hellodrv 是创建的类的名字；；hello_drv 才是驱动的名字，hellodrv只是驱动创建的一个类，类下面的设备节点 xyz，主副设备号 对应的 驱动 才是 hello_drv ；；；；； 1234567891011121314151617181920212223242526272829303132# ls -l /dev/xyzcrw-r--r-- 1 0 0 252, 0 Jan 1 01:57 /dev/xyz# lsMakefile hello3_drv.c hello3_drv.mod.o hello3drvtest.cModule.symvers hello3_drv.ko hello3_drv.o ledhello hello3_drv.mod.c hello3drvtest# cd # lsbin etc lib mnt sbin usrdev hann linuxrc proc sys# cd sys ///在主目录下的系统文件夹下，有个一个class类# lsblock class firmware kernel powerbus devices fs module# cd class# lsgraphics mem ppdev scsi_host usb_hosthellodrv misc printer sound vchwmon mmc_host rtc spi_master vtconsolei2c-adapter mtd scsi_device ttyinput net scsi_disk usb_endpoint# cd hellodrv ///类里面有在驱动程序 init的 hellodrv，，，，在这个类里面有一个dev设备# lsxyz# cd xyz# lsdev subsystem uevent# cd dev-sh: cd: can't cd to dev# cat dev ///打开设备发现 是这个设备的主设备号码 251:0# 下面分别对应hello2 hello3的程序 hello2对应的hello2的驱动程序为123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/delay.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/irq.h&gt;#include &lt;asm/io.h&gt;#include &lt;asm/arch/regs-gpio.h&gt;#include &lt;asm/hardware.h&gt;static int hello_drv_open(struct inode *inode, struct file *file)&#123; printk(\" this is my first devices\\n\"); return 0;&#125;static ssize_t hello_drv_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)&#123; printk(\" hello_drv_write000000\\n\"); return 0;&#125;static struct file_operations hello_drv_fops = &#123; .owner = THIS_MODULE, /* 这是一个宏，推向编译模块时自动创建的__this_module变量 */ .open = hello_drv_open, .write = hello_drv_write,&#125;;static int hello_drv_init(void)&#123; register_chrdev(0, \"hello_drv\", &amp;hello_drv_fops); // 注册, 告诉内核&#125;static void hello_drv_exit(void)&#123; unregister_chrdev(0, \"hello_drv\"); // 卸载&#125;module_init(hello_drv_init);module_exit(hello_drv_exit);MODULE_LICENSE(\"GPL\"); 测试程序为：123456789101112131415161718#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; int fd; int val = 1; fd = open(\"/dev/xyz\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open!\\n\"); &#125; write(fd, &amp;val, 4); return 0;&#125; hello3对应的hello3的驱动程序为12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/delay.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;asm/irq.h&gt;#include &lt;asm/io.h&gt;#include &lt;asm/arch/regs-gpio.h&gt;#include &lt;asm/hardware.h&gt;static struct class *hellodrv_class;static struct class_device *hellodrv_class_dev;static int hello_drv_open(struct inode *inode, struct file *file)&#123; printk(\" this is my first devices\\n\"); return 0;&#125;static ssize_t hello_drv_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)&#123; printk(\" hello_drv_write000000\\n\"); return 0;&#125;static struct file_operations hello_drv_fops = &#123; .owner = THIS_MODULE, /* 这是一个宏，推向编译模块时自动创建的__this_module变量 */ .open = hello_drv_open, .write = hello_drv_write,&#125;;int major;static int hello_drv_init(void)&#123; major =register_chrdev(0, \"hello_drv\", &amp;hello_drv_fops); // 注册, 告诉内核 hellodrv_class = class_create(THIS_MODULE, \"hellodrv\"); hellodrv_class_dev = class_device_create(hellodrv_class, NULL, MKDEV(major, 0), NULL, \"xyz\"); /* /dev/xyz */ return 0;&#125;static void hello_drv_exit(void)&#123; unregister_chrdev(major, \"hello_drv\"); // 卸载 class_device_unregister(hellodrv_class_dev); class_destroy(hellodrv_class);&#125;module_init(hello_drv_init);module_exit(hello_drv_exit);MODULE_LICENSE(\"GPL\"); 测试程序为： 12345678910111213141516171819#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; int fd; int val = 1; fd = open(\"/dev/xyz\", O_RDWR); if (fd &lt; 0) &#123; printf(\"can't open!\\n\"); &#125; write(fd, &amp;val, 4); return 0;&#125; 点亮一个led灯1.搭建框架，比如上面所做的工作；2.框架的完善，硬件部分的操作；看原理图、芯片手册、写代码（单片机是直接操作物理地址，驱动程序是操作虚拟地址（虚拟地址用ioremap进行物理地址和虚拟地址的映射））开发板三个灯的引脚分别是GPF4/5/6；单片机中，对io口操作，就是gpf con控制寄存器 和date 数据寄存器在2440手册中查找GPFCON 查询到f端口的地址，配置GPFCON: OPEN设置GPFDAT： write 其中用到一个函数 strcmp（char1，char2） C/C++函数，比较两个字符串 设这两个字符串为str1，str2， 若str1==str2，则返回零; 若str1&gt;str2，则返回正数; 若str1","tags":[{"name":"2440驱动","slug":"2440驱动","permalink":"http://yoursite.com/tags/2440驱动/"}]},{"title":"博文建设常用模板知识","date":"2017-09-18T03:04:51.000Z","path":"2017/09/18/模板/","text":"#目录隐藏：1&lt;!-- more --&gt; #tags：12345678menu: 主 页: / 博 客: /tags/搞github心得 随 笔: /tags/心随意动 基 础: /tags/linux平台搭建 驱 动: /tags/2440驱动 单片机: /tags/单片机研究 硬 件: /tags/硬件项目 #空格：1&amp;nbsp dfgagfdagadfgda #居中1&lt;p align=\"center\"&gt;居中字体内容 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自 www.cetiic.cn ，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[]},{"title":"insmod驱动之前的工作","date":"2017-09-14T13:59:51.000Z","path":"2017/09/14/insmod驱动之前的工作/","text":"&nbsp;&nbsp;&nbsp;&nbsp;根据自己的思路理解，我本应该直接搞驱动，奈何不停的回到平台搭建部分。insmod驱动之前需要挂载nfs，挂载这个无非就是想把电脑的.ko搞到开发板上加载，但是nfs挂载的前提就是开发板和ubunt的互通。那么问题又来了我电脑的ip和开发板的不在一个网段上，我又不愿意电脑和开发板直连，修改电脑ip迎合开发板。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，有了这篇文章，对我来说意义很大，抽空补全 NFS 启动时候出现的问题 &nbsp;&nbsp;&nbsp;&nbsp;其实我想要搞定的问题很简单，就是一个简单的NFS自动挂载。可是自己不会搞，别人也不一定会，或者会并不知道你要搞什么，所以浪费了不少时间； nfs无法启动 原因1简单粗暴点 就是搞驱动的时候无法insmod 解决办法1手动挂载：1$ mount -t nfs -o nolock 172.18.1.164:/work/nfs_root /tmp 注意：nolock是非阻塞方式；172.18.1.164 是我ubunt的ip，:/work/nfs_root是ubunt上需要挂载的文件夹目录，%%%注意 /tmp， /tmp之前有空格，你不注意肯定搞不定，这个是2440板子上的文件目录，挂载到这里 解决办法2nfs自动挂载 123456789101112nfs启动时出现IP-Config: Complete:device=eth0, addr=192.168.0.100, mask=255.255.255.0, gw=192.168.0.1, host=192.168.0.100, domain=, nis-domain=(none), bootserver=192.168.0.133, rootserver=192.168.0.133, rootpath=Looking up port of RPC 100003/2 on 192.168.0.133Looking up port of RPC 100005/1 on 192.168.0.133VFS: Mounted root (nfs filesystem).Freeing init memory: 140Kinit started: BusyBox v1.7.0 (2008-01-22 10:04:09 EST)starting pid 765, tty '': '/etc/init.d/rcS'nfs: server 192.168.0.133 not responding, still trying 这个只是示意，starting pid 765, tty ‘’: ‘/etc/init.d/rcS’nfs: server 192.168.0.133 not responding, still trying 出现这个现象，根本原因：虚拟机里提供的网络文件系统中的 /work/nfs_roots/xxx/etc/init.d/rcS 有一句修改开发板ip的指令：ifconfig eth0 192.168.1.17 nfs 启动的原理，这里简单讲一下，我们在 boot 中设置了 bootargs 参数，例如：bootargs noinitrd root=/dev/nfs console=ttySAC0 nfsroot=192.168.1.101:/work/nfs_root/fs_mini_mdev ip=192.168.1.253:192.168.1.101:192.168.1.1:255.255.255.0::eth0:off init=/linuxrc 在这里我们指定了开发板ip,主机（虚拟机）ip等信息，在uboot启动内核时会将这些信息传递给内核，内核在启动过程中会根据这些参数来挂载网络根文件系统（位于虚拟机的 nfs_root 目录下），挂载成功之后才会访问 /etc/init.d/rcS 。也就是说，在内核启动的过程中开发板ip已经根据 Bootargs 里指定的Ip设置完毕 ,nfs 启动后我们无需在 /etc/init.d/rcS 中再次更改一次ip，一旦更改了ip 还不在一个网段的话，就会出现上面的这种情况。 解决办法，更改你所设置的网络文件系统目录下的 /etc/init.d/rcS 中的修改ip 的指令即可。举例：/work/nfs_root/fs_mini_mdev/etc/init.d/rcS 遗留的问题当然 还有很多遗留问题，这里不关注，那是后面需要解决的问题，不然无外援，寸步难行。 其它常用开发板ping 设置ping包的次数1&amp;ping -c 6 ip 居中1234567891011121314&lt;html&gt;&lt;head&gt;&lt;title&gt;我的青春&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p align=\"center\"&gt;我的青春 &lt;/p &gt;&lt;body&gt;&lt;/html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;我的青春&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p align=\"center\"&gt;我的青春 &lt;/p &gt;&lt;body&gt;&lt;/html&gt;&lt;body&gt;&lt;p align=\"center\"&gt;我的青春 &lt;/p &gt;&lt;body&gt;&lt;p align=\"center\"&gt;我的青春 空格1&amp;nbsp 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自 www.cetiic.cn ，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"linux平台搭建","slug":"linux平台搭建","permalink":"http://yoursite.com/tags/linux平台搭建/"}]},{"title":"'建立博客的初衷'","date":"2017-09-14T13:18:20.000Z","path":"2017/09/14/建立博客的初衷/","text":"&nbsp;&nbsp;&nbsp;&nbsp;咨询hceng linux的时候，发现其使用github，并督促自己学习驱动。感觉自己也可以这么干，还可以绑定一个域名玩玩。把自己的缺点尽情的暴露出来。这样才能有更大的进步。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自 www.cetiic.cn ，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"心随意动","slug":"心随意动","permalink":"http://yoursite.com/tags/心随意动/"}]},{"title":"github pages","date":"2017-09-10T11:08:17.000Z","path":"2017/09/10/github-pages/","text":"非软件出身，并特别粗心的我，在建github的过程中遇到了一定的困难。关于这两天搞 github遇到了不少问题，开始的完全不懂，慢慢的的感觉就这么回事。有#hceng的好心帮助，也有@闻道的帮助与讽刺及@Маленький гриб的调侃。等手头的事情告一段落，我会把建站一路中遇到的问题，及正确的步骤做一份详细的文档。留念 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自 www.cetiic.cn ，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[{"name":"搞github心得","slug":"搞github心得","permalink":"http://yoursite.com/tags/搞github心得/"}]},{"title":"Hello World","date":"2017-09-10T02:38:00.810Z","path":"2017/09/10/hello-world/","text":"Welcome to Hexo!This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，欢迎转载，但转载请注明来自 www.cetiic.cn ，并保持转载后文章内容的完整。本人保留所有版权相关权利。","tags":[]}]